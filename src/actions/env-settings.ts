"use server";

import { db } from "@/db";
import { users } from "@/db/schema";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { eq } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import * as fs from "fs/promises";
import * as path from "path";

// Verify admin access
async function requireAdmin() {
    const session = await auth.api.getSession({
        headers: await headers(),
    });
    if (!session?.user) {
        throw new Error("Unauthorized");
    }

    const user = await db.query.users.findFirst({
        where: eq(users.id, session.user.id),
    });

    if (!user || user.role !== "ADMIN") {
        throw new Error("Admin access required");
    }

    return user;
}

// Allowed environment variables that can be modified
const ALLOWED_ENV_KEYS = [
    "NEXT_PUBLIC_APP_URL",
    "BETTER_AUTH_URL",
    "EMAIL_FROM",
    "SMTP_HOST",
    "SMTP_PORT",
] as const;

type AllowedEnvKey = typeof ALLOWED_ENV_KEYS[number];

// Path to .env.local file (safer than modifying .env)
const ENV_FILE_PATH = path.join(process.cwd(), ".env.local");

// ============================================
// GET ENVIRONMENT SETTINGS
// ============================================
export async function getEnvSettings(): Promise<Record<AllowedEnvKey, string>> {
    await requireAdmin();

    // Return current values from process.env
    const settings: Record<string, string> = {};

    for (const key of ALLOWED_ENV_KEYS) {
        settings[key] = process.env[key] || "";
    }

    return settings as Record<AllowedEnvKey, string>;
}

// ============================================
// READ .env.local FILE CONTENTS
// ============================================
async function readEnvFile(): Promise<Map<string, string>> {
    const envMap = new Map<string, string>();

    try {
        const content = await fs.readFile(ENV_FILE_PATH, "utf-8");
        const lines = content.split("\n");

        for (const line of lines) {
            const trimmed = line.trim();
            // Skip empty lines and comments
            if (!trimmed || trimmed.startsWith("#")) continue;

            const eqIndex = trimmed.indexOf("=");
            if (eqIndex === -1) continue;

            const key = trimmed.substring(0, eqIndex).trim();
            let value = trimmed.substring(eqIndex + 1).trim();

            // Remove quotes if present
            if ((value.startsWith('"') && value.endsWith('"')) ||
                (value.startsWith("'") && value.endsWith("'"))) {
                value = value.slice(1, -1);
            }

            envMap.set(key, value);
        }
    } catch (error) {
        // File doesn't exist, return empty map
        console.log("[EnvSettings] .env.local not found, will create new file");
    }

    return envMap;
}

// ============================================
// WRITE .env.local FILE
// ============================================
async function writeEnvFile(envMap: Map<string, string>): Promise<void> {
    const lines: string[] = [
        "# Auto-generated by Admin Settings",
        `# Last updated: ${new Date().toISOString()}`,
        "",
    ];

    for (const [key, value] of envMap) {
        // Quote values that contain spaces or special characters
        const needsQuotes = value.includes(" ") || value.includes("#") || value.includes("=");
        const quotedValue = needsQuotes ? `"${value}"` : value;
        lines.push(`${key}=${quotedValue}`);
    }

    await fs.writeFile(ENV_FILE_PATH, lines.join("\n"), "utf-8");
}

// ============================================
// UPDATE ENVIRONMENT SETTINGS
// ============================================
export async function updateEnvSettings(
    updates: Partial<Record<AllowedEnvKey, string>>
): Promise<{ success: boolean; message: string }> {
    await requireAdmin();

    try {
        // Read existing .env.local
        const envMap = await readEnvFile();

        // Update with new values
        for (const [key, value] of Object.entries(updates)) {
            if (ALLOWED_ENV_KEYS.includes(key as AllowedEnvKey)) {
                if (value && value.trim()) {
                    envMap.set(key, value.trim());
                }
            }
        }

        // Write back to file
        await writeEnvFile(envMap);

        revalidatePath("/admin/settings");

        return {
            success: true,
            message: "Pengaturan berhasil disimpan. Restart aplikasi untuk menerapkan perubahan.",
        };
    } catch (error) {
        console.error("[EnvSettings] Failed to update:", error);
        return {
            success: false,
            message: `Gagal menyimpan pengaturan: ${error}`,
        };
    }
}

// ============================================
// GET ALL ENV SETTINGS (from file + current process)
// ============================================
export async function getFullEnvSettings(): Promise<{
    current: Record<AllowedEnvKey, string>;
    file: Record<string, string>;
}> {
    await requireAdmin();

    // Current values from process.env
    const current: Record<string, string> = {};
    for (const key of ALLOWED_ENV_KEYS) {
        current[key] = process.env[key] || "";
    }

    // Values from .env.local file
    const envMap = await readEnvFile();
    const file: Record<string, string> = {};
    for (const [key, value] of envMap) {
        file[key] = value;
    }

    return {
        current: current as Record<AllowedEnvKey, string>,
        file,
    };
}
